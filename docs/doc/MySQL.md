# MySQL面试题

### 常见的SQL优化方案

- 从设计角度优化
  - 服务降级（限流，限定查询范围）
  - 选择正确的存储引擎
  - 建立合适的索引
  - 分库分表（水平分表，垂直分表）
  - 建立异构索引表
  - 限定查询范围
- 从中间件角度优化
  - 热点数据采用NoSql代替
  - 模糊查询采用ES代替
- 从高可用角度优化
  - 做数据库的读写分离，分布式
  - 定期清理不用的数据，定时进行碎片整理
  - 配置比较高的mysql并发数
  - 使用数据库连接池
  - 服务器优化（操作系统和硬件）

### Mysql为什么要使用B+Tree

- 红黑树：数据量大的情况下，树的高度很高，查询效率低。
- 哈希索引：哈希值是无序，不能进行范围查找
- AVL（平衡二叉树）：随着高度的增加，查找的速度变慢，范围查找虽然可以查，但是很慢，因为要回旋
- B-Tree:解决了AVL高度太高的问题，一个节点存多个数据，所以它的查找速度很快，但范围查找的回旋问题没有解决
- B+Tree:在B-Tree的基础上解决了回旋查找的问题，叶子节点是一个双向链表，这样范围查找很快。mysql索引使用B+Tree，索引放在磁盘上。

### B+Tree相比BTree的优势和劣势

- 根节点只保存关键字，不保存数据，同样的磁盘页可以有更多的分支
- 所有的数据都保存在叶子页面，所以查找比较稳定，总是在叶子节点可以找到数据
- 叶子节点的数据的尾指针总是指向下一个数据页的头指针，所以对于范围查询很友好，也不用回溯到上一个节点去查找数据，减少磁盘I/O
- B+Tree的劣势是，每次查找数据总是要到达叶子节点才能拿到真实的数据。

### 如何建立合适的索引

- 一般情况下建议为搜索条件、排序、分组的字段建立索引
- 建议为离散程度较高的字段建立索引，否则会产生大量的回表，导致产生大量的I/O
- 索引列的数量尽可能少，因为每个索引的建立就要维护一个B+Tree，所以有维护成本
- 选择的建立的索引列的字符串长度尽可能的小，因为InnoDB以页为存储单位，如果小的话，读取一页加载到内存的数据更多
- 尽量建立覆盖索引
- 对于索引列的字符串长度较大的，可以考虑建立前缀索引，或者后缀索引
- 表的设计ID使用主键自增，防止发生InnoDB页分裂
- 如果高频率的必要，尽量不建立索引

### 常见的索引失效

- 没有满足最左匹配原则
- 索引列参与运算
- 错误的like使用
- 存在隐式转换
- OR的使用
- 两列作比较
- Server层优化器生产的执行计划效率低下

### Mysql常见锁以及使用方法



### 一条SQL的执行流程



### Innodb事务如何回滚 && Innodb实现事务的过程

- InnoDB在接收到update语句后，会先根据条件查找出数据所在的页，然后将这一页的数据缓存到Buffer Pool缓冲池中。

- 执行update语句，修改缓存到Buffer Pool中的数据。
- 针对update语句生成一个redo log重做日志，并将redo log保存到 Log Buffer日志缓冲区。
- 针对update语句生成undo log回滚日志，用于事务回滚，保证原子性。
- 如果要提交事务，则将redo log持久化，将其持久化到磁盘上，保证事务的持久性。持久化redo log后，MySQl会使用其他机制，将Buffer Pool缓冲池中修改的数据页持久化到磁盘中。
- 如果事务回滚，则利用undo log回滚日志进行事务回滚。

### Mysql宕机后如何恢复数据

- checkpoint 表示完整刷到磁盘的 data page 上的 LSN 版本号，因此仅恢复从 checkpoint 开始的数据部分
- 如果数据页的LSN小于日志页的LSN，说明事务已经commit，则进行数据恢复
- 还有一种情况，宕机的时候正处于checkpoint刷盘过程，所以会发现checkpoint大于数据页的LSN，说明数据已经刷盘，所以无需刷盘

### Mysql宕机后为什么不用binlog恢复数据

事务具有幂等性，多次操作的同一结果在日志中只记录一次。但是binlog数据存档性日志，多次操作的记录都会记录下来，所以在数据恢复中采用binlog速度会慢很多。

### MVCC以及隔离级别

MVCC就是在RC和RR状态下，访问redo-log版本链的过程。这样就让：读-读，读-写，写-读，可以并发的执行，而不需要加锁，从而实现性能的提升。

**undo-log版本链中两个记录值**

- Trx_id：每次修改都会把事务的id赋值它。
- roll_pointer：下一个事务的指针指向上一个事务，形成一个版本链表。

**ReadView包含的内容**

- Min_ids：在生成ReadView中活跃的事务
- Min_trx_id：在生成ReadView中，当前活跃事务的最小id
- Max_trx_id：在生成ReadView中，系统应该分配给下一个事务的id。（并不是事务的最大id，事务的id是自增的。比如有：T1、T2、T3 三个事务，现在事务 T3 提交了，那么事务 Tn 新生成的 ReadView是：m_id={1,2}，min_trx_id=1，max_trx_id=4）
- Creator_trx_id：生成ReadView的事务的事务id

**数据可见性判断方法**

1. 如果访问版本的 trx_id = creator_trx_id，那么对于该版本可见
2. 如果访问版本的 trx_id < min_trx_id，说明该事务已提交，所以可见
3. 如果访问版本的 trx_id > max_trx_id，表明生成该版本的事务在生成该版本的ReadView后才开启，所以对该版本不可见
4. 如果访问版本的 trx_id 介于 min 和 max 之间，则要判断是否在 m_ids 中。如果在，说明创建 ReadView 时生成的该版本事务是活跃的，则不可被访问。如果不在，则说明事务已经提交了，则可见。

### 为什么不建议字段设计为NULL

mysql在存储一行数据的时候分为两部分，分别是：额外部分，真实数据部分。如果字段中存在NULL，则mysql需要在 "额外部分" 单独维护一个 NULL 值列表（使用bit记录，null值则标记是1，如果存在数据则标记为0）。假如设计的字段都不存在 NULL 值，那么 "额外部分" 则不需要 NULL 值列表去维护这个 NULL 字段。所以说如果存在 NULL 值会让这一切（CRUD）变得复杂起来。

### Mysql服务器CPU飙升如何排查问题

- 首先在Linux使用top命令确定是否mysql服务的问题
- 是否存在连接没有被释放
- 判断是否Cache层的服务宕机
- 是否连接数量配置过多，导致内存消耗过大，进而引发高频次的GC
- 由于SQL中锁的使用不当，可以查看慢日志
- 由于SQL中存在死锁，可以查看错误日志

